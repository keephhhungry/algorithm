package zuo.level1.class5;

/**
 * @author ： cxyxh
 * @date : 2021/7/3 15:46
 * @describetion : 用位运算实现加减乘除
 * 测试链接：https://leetcode.com/problems/divide-two-integers
 */
public class Code02_BitAddMinusMultiDiv {

    /**
     * 用位运算实现加法运算
     * <p>
     * a+b 等于 a^b + a&b(记住)
     * a^b = a1  a&b = b1
     * 由于不能出现加法，所以得到两个新的值的时候，只要后面的值为0，那么就不会用上加号，计算就完成了
     * 如果得到两个值后面一个不为0，那么继续对他进行位运算进行计算
     * <p>
     * 例子如下：
     * 第一轮：
     * a = 46 = 32 + 8 + 4 + 2 = 0 0 1 0 1 1 1 0
     * b = 20 = 16 + 4         = 0 0 0 1 0 1 0 0
     * a + b = 66
     * ------------------------------------------------
     * a  0 0 1 0 1 1 1 0          a  0 0 1 0 1 1 1 0
     * ^ b  0 0 0 1 0 1 0 0        & b  0 0 0 1 0 1 0 0
     * =  0 0 1 1 1 0 1 0          =  0 0 0 0 0 1 0 0
     * <<1 =  0 0 0 0 1 0 0 0
     * = 58                        =  8
     * =================================================
     * 第二轮：
     * a1 = 58 = 32 + 16 + 8 + 2 = 0 0 1 1 1 0 1 0
     * b1 = 08 = 8               = 0 0 0 0 1 0 0 0
     * a1 + b' = 66
     * --------------------------------------------------
     * a1  0 0 1 1 1 0 1 0          a1  0 0 1 1 1 0 1 0
     * ^ b1  0 0 0 0 1 0 0 0        & b1  0 0 0 0 1 0 0 0
     * =   0 0 1 1 0 0 1 0          =   0 0 0 0 1 0 0 0
     * <<1 =   0 0 0 1 0 0 0 0
     * = 50                         =   16
     * ==================================================
     * 第三轮：
     * a2 = 50 = 32 + 16 + 2 = 0 0 1 1 0 0 1 0
     * b2 = 16 = 16          = 0 0 0 1 0 0 0 0
     * a2 + b2 = 66
     * --------------------------------------------------
     * a2  0 0 1 1 0 0 1 0          a2  0 0 1 1 0 0 1 0
     * ^ b2  0 0 0 1 0 0 0 0        & b2  0 0 0 1 0 0 0 0
     * =   0 0 1 0 0 0 1 0          =   0 0 0 1 0 0 0 0
     * <<1 =   0 0 1 0 0 0 0 0
     * = 34                         =   32
     * ==================================================
     * 第四轮：
     * a3 = 34 = 32 + 2 = 0 0 1 0 0 0 1 0
     * b3 = 32 = 32     = 0 0 1 0 0 0 0 0
     * a3 + b3 = 66
     * --------------------------------------------------
     * a3  0 0 1 0 0 0 1 0          a3  0 0 1 0 0 0 1 0
     * ^ b3  0 0 1 0 0 0 0 0        & b3  0 0 1 0 0 0 0 0
     * =   0 0 0 0 0 0 1 0          =   0 0 1 0 0 0 0 0
     * <<1 =   0 1 0 0 0 0 0 0
     * = 2                          =   64
     * ==================================================
     * 第五轮：
     * a4 = 02 = 02 = 0 0 0 0 0 0 1 0
     * b4 = 64 = 64 = 0 1 0 0 0 0 0 0
     * a4 + b4 = 66
     * --------------------------------------------------
     * a4  0 0 0 0 0 0 1 0          a4  0 0 0 0 0 0 1 0
     * ^ b4  0 1 0 0 0 0 0 0        & b4  0 1 0 0 0 0 0 0
     * =   0 1 0 0 0 0 1 0          =   0 0 0 0 0 0 0 0
     * <<1 =  0 0 0 0 0 0 0 0
     * = 66                          =   0
     * <p>
     * 第二个值为0，位运算结束
     *
     * @param a
     * @param b
     * @return
     */
    public static int add(int a, int b) {
        int sum = a;
        while (b != 0) {
            sum = a ^ b;
            b = (a & b) << 1;
            a = sum;
        }
        return sum;
    }

    /**
     * 用位运算实现减法
     * a - b = a + (-b)
     * 由于不能使用减法符号
     * a - b = a + (~b + 1)
     * 由于也不能使用加法符号
     * a - b = add(a,add(~b,1))
     *
     * @param a
     * @param b
     * @return
     */
    public static int minus(int a, int b) {
        return add(a, negNum(b));
    }

    /**
     * 取负数的绝对值
     *
     * @param n
     * @return
     */
    public static int negNum(int n) {
        return add(~n, 1);
    }

    /**
     * 用位运算实乘法
     * 例子如下：
     * <p>
     * a = 6 = 0 1 1 0
     * b = 7 = 0 1 1 1
     * <p>
     * a = 0 1 1 0
     * * b = 0 1 1 1
     * ---------------
     * 0 1 1 0(第一位，a的二进制直接写下来，a左移一位)
     * 0 1 1 0 0(第二位，a已经左移一位了，a的二进制直接写下来，a再左移一位)
     * 0 1 1 0 0 0(第三位，a已经左移两位了，a的二进制直接写下来，a再左移一位)
     * <p>
     * b从右往左一位一位的看，如果是1，那么把a的二进制加上去，并且a左移一位；如果是0，那么不用加，a左移一位即可
     * 这样把乘法转换成了加法
     *
     * @param a
     * @param b
     * @return
     */
    public static int multi(int a, int b) {
        int res = 0;
        while (b != 0) {
            if ((b & 1) != 0) {
                res = add(res, a);
            }
            a <<= 1;
            b >>>= 1;
        }
        return res;
    }


    /**
     * 位运算实现除法
     *
     * @param a
     * @param b
     * @return
     */
    public static int divide(int a, int b) {
        // 如果除数和被除数都是int类型的最小值，那么直接返回1
        if (a == Integer.MIN_VALUE && b == Integer.MIN_VALUE) {
            return 1;
            // 如果除数是int类型的最小值，那么直接返回0
        } else if (b == Integer.MIN_VALUE) {
            return 0;
            // 如果被除数是int类型的最小值
        } else if (a == Integer.MIN_VALUE) {
            // 如果除数的绝对值是1，那么直接返回int的最大值。LeetCode规定
            if (b == negNum(1)) {
                return Integer.MAX_VALUE;
                // 如果不是，把被除数+1再除以b
            } else {
                /**
                 * a/b
                 * (a+1) / b = c
                 * a - (b * c) = d
                 * d / b = e
                 * c + e
                 *
                 * 例子：假如-15是int类型的负数最小值，14是最大值
                 * -15 / -5 = 3
                 * (-15 + 1) / -5 = 2
                 * -15 - ( -5 * 2) = -5
                 * -5 / -5 = 1
                 * ans = 2 + 1
                 */
                int c = div(add(a, 1), b);
                return add(c, div(minus(a, multi(c, b)), b));
            }
            // 如果a，b都不是int类型的最小值，那么调用位运算实现除法的核心算法
        } else {
            return div(a, b);
        }
    }

    /**
     * 位运算实现除法的核心逻辑
     *
     * 例子：22 /7
     *
     * 第一轮：
     * a = 22 = 0 1 0 1 1 0
     * b = 7  = 0 0 0 1 1 1
     *
     * a移动两位后变成 0 0 0 1 0 1
     * 比            0 0 0 1 1 1
     * 来的小，所以a最多往右移动一位，所以答案 右边第一位是1
     *
     * a减去     0 1 0 1 1 0
     * b左移一位 0 0 1 1 1 0
     * 得到a新值 0 0 1 0 0 0
     * -------------------------------------------------
     * 第一轮：
     * a = 0 0 1 0 0 0
     * b = 0 0 0 1 1 1
     *
     * a最多往右边移动0位置，所以答案的 右边第0为是1
     *
     * a减去     0 0 1 0 0 0
     * b左移一位 0 0 0 1 1 1
     * 得到a新值 0 0 0 0 0 1
     *-------------------------------------------------
     * a = 0 0 0 0 0 1
     * b = 0 0 0 1 1 1
     *
     * 此时移动位置已经到了0，运算结束
     * 而刚刚过程中我们得到0和1位置的数字是1
     * ans = 0 1 1 = 3
     *
     * @param a
     * @param b
     * @return
     */
    public static int div(int a, int b) {
        // x ，y 分别是a ，b的绝对值，因为除法只适用于正数
        int x = isNeg(a) ? negNum(a) : a;
        int y = isNeg(b) ? negNum(b) : b;
        int res = 0;
        // 因为是正数，所以符号位一定是0，所以右移0位就可以
        for (int i = 30; i >= 0; i = minus(i, 1)) {
            if ((x >> i) >= y) {
                // 因为每次答案的角标位置都不相同，这里会起到加法的作用
                res |= (1 << i);
                // x减去y左移i位
                x = minus(x, y << i);
            }
        }
        // 如果符号相同返回正数，否则返回相反数
        return isNeg(a) ^ isNeg(b) ? negNum(res) : res;
    }

    /**
     * 判断是否是负数
     *
     * @param n
     * @return
     */
    public static boolean isNeg(int n) {
        return n < 0;
    }

    public static void main(String[] args) {
        System.out.println(add(46, 20));
    }

}
