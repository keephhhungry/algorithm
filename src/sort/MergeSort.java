package sort;

import java.util.Arrays;

/**
 * @author ： cxyxh
 * @date : 2021/6/24 0:40
 * @describetion : 归并排序
 * <p>
 * 简介：
 * 归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法的一个非常典型的应用。
 * 将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。
 * <p>
 * 两种方法算法描述：
 * <p>
 * 递归法（Top-down）
 * 1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
 * 2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置
 * 3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
 * 4. 重复步骤3直到某一指针到达序列尾
 * 5. 将另一序列剩下的所有元素直接复制到合并序列尾
 * <p>
 * 迭代法（Bottom-up）
 * 1. 原理如下（假设序列共有n个元素）：
 * 2. 将序列每相邻两个数字进行归并操作，形成ceil(n/2)个序列，排序后每个序列包含两/一个元素
 * 3. 若此时序列数不是1个则将上述序列再次归并，形成ceil(n/4)个序列，每个序列包含四/三个元素
 * 4. 重复步骤2，直到所有元素排序完毕，即序列数为1
 * <p>
 * 稳定性：
 * 因为我们在遇到相等的数据的时候必然是按顺序“抄写”到辅助数组上的，所以，归并排序同样是稳定算法。
 * <p>
 * 适用场景：
 * 归并排序在数据量比较大的时候也有较为出色的表现（效率上），
 * 但是，其空间复杂度O(n)使得在数据量特别大的时候（例如，1千万数据）几乎不可接受。
 * 而且，考虑到有的机器内存本身就比较小，因此，采用归并排序一定要注意。
 */
public class MergeSort {

    public static void main(String[] args) {
        int[] arr = {3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48};
        mergeSort(arr);
        System.out.println(Arrays.toString(arr));
    }

    // 递归方法实现
    public static void mergeSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        process(arr, 0, arr.length - 1);
    }

    // arr[L...R]范围上，请让这个范围上的数，有序！

    /**
     *                                  f(0,0)
     *                          f(0,1)
     *                        /         f(1,1)
     *                  f(0,3)
     *                  /     \         f(2,2)
     *                 /        f(2,3)
     *                /                 f(3,3)
     *          f(0,7)
     *           /    \                 f(4,4)
     *          /      \        f(4,5)
     *         /        \     /         f(5,5)
     *        /          f(4,7)
     *       /                \         f(6,6)
     *      /                   f(6,7)
     *     /                            f(7,7)
     * f(0,14)
     *     \
     *      \
     *       \                          f(8,8)
     *        \                  f(8,9)
     *         \                 /      f(9,9)
     *          \        f(8,11)
     *           \         /     \      f(10,10)
     *            \       /      f(10,11)
     *             \     /              f(11,11)
     *           f(8,14)
     *                \
     *                 \                f(12,12)
     *                  \        f(12,13)
     *                   \     /        f(13,13)
     *                    f(12,14)
     *                         \
     *                            f(14,14)
     *
     *  如上图所示：
     *      该数组首次进来的L=0,R=14,第一次确定mid=7，进入第一次递归，此时进来的L=0,R=7。mid=3，再次进入递归
     *      层层递归，直到f(0,1) L=0,R=1，mid=0的时候。此时递归进来，进入的两次process递归方法全部直接返回。进入merge方法，merge方法把0,1范围上的数字按顺序排列
     *      该递归返回后，会进入f(2,3) L=2,R=3,mid=2的时候，此时递归进来，进入的两次process递归方法全部直接返回。进入merge方法，merge方法把2，,3范围上的数字按顺序排列
     *      该递归返回后，会进入f(0,3) L=0,R=3,mid=2的时候，此时是递归出来，所以进入merge方法，merge方法把0，,3范围上的数字按顺序排列
     *      以此类推，直到整个数组有序
     * @param arr
     * @param L
     * @param R
     */
    public static void process(int[] arr, int L, int R) {
        // 如果排序的范围只有一个数，那么直接返回
        if (L == R) {
            return;
        }
        // 找到中点
        int mid = L + ((R - L) >> 1);
        // 对左边的范围进行确定
        process(arr, L, mid);
        // 对右边的范围进行确定
        process(arr, mid + 1, R);
        // 确定好范围，开始排序
        merge(arr, L, mid, R);
    }

    /**
     * @param arr 数组
     * @param L   左边角标
     * @param M   中点角标
     * @param R   右边角标
     */
    public static void merge(int[] arr, int L, int M, int R) {
        // 创建一个辅助数组
        int[] help = new int[R - L + 1];
        int i = 0;
        int p1 = L;
        int p2 = M + 1;
        // 左边的数组是L~M 右边的数组是M+1~R。如果p1不越界，并且p2不越界的话，
        // 如果p1的值比p2小，那么把p1的值加到help数组中，p1++,i++;如果p1的值比p2大，那么把p2的值加到help数组中，p2++,i++;
        while (p1 <= M && p2 <= R) {
            help[i++] = arr[p1] <= arr[p2] ? arr[p1++] : arr[p2++];
        }
        // 要么p1越界，要么p2越界
        // 不可能出现：共同越界,没有越界的半边把剩下的数传完
        while (p1 <= M) {
            help[i++] = arr[p1++];
        }
        while (p2 <= R) {
            help[i++] = arr[p2++];
        }
        // 因为只需要排序L~R，最后把辅助数组的值从L+0开始添加到arr数组中
        for (i = 0; i < help.length; i++) {
            arr[L + i] = help[i];
        }
    }
}
